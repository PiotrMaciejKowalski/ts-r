---
title: "Wprowadzenie do badania stacjonarności szeregów czasowych oraz modele ARIMA"
author: "Piotr Kowalski"
date: "3 kwietnia 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Szeregi czasowe w R

Rozpocznijmy od danych pobranych ze [strony](https://www.money.pl/gielda/spolki-gpw/PLPGNIG00014,archiwum.html) 

```{r}
url = 'data/example-data.csv'
df = read.csv(url)
head(df)
```

Dane są obecnie przechowywane w postaci ramki danych. R posiada typ danych stworzony specjalnie z myślą o modelowaniu szeregów czasowych. Nazywa się ts

```{r}
sc = ts(df$Otwarcie, frequency = 1)
dates = as.Date(df$Data, format='%Y-%m-%d')
sessional_sc = ts(df$Otwarcie, frequency = 5)
sc
```

Składnie tych obiektów można sprawdzić pisząc

```{r}
?ts
```

## Manipulacja typem danych ts

Prosty wykres

```{r}
plot(sc)
```

## Wykres ACF

```{r}
acf(sc)
```


```{r}
pacf(sc)
```

## Próba dekompozycji addytywnej

Sprawdźmy szybko czy nasze zjawisko nie jest sumą deterministycznego trendu i części probabilistycznej.

```{r}
plot(decompose(sessional_sc,"additive"))
```

## Podstawowe wykresy

```{r}
library(forecast)
tsdisplay(sc)
```

## Różnicowanie szeregu

```{r}
plot(diff(sc))
```

```{r}
acf(diff(sc))
```

Funkcje z pakietu forecast

```{r}
library(forecast)
Acf(sc)
Pacf(sc)
autoplot(sc)
```

## Pakiet ggplot

```{r}
library(ggplot2)
ggAcf(sc)
ggPacf(sc)

```

# Badanie szeregów stacjonarnych

```{r}
library(forecast)
```

```{r}
?forecast::auto.arima
```

## Podział na zbiór treningowy i testowy

Dokonamy podziału naszego zbioru na część treningową i testową

```{r}
length(sc)
```

```{r}
sc.train = window(sc,end = 60)
sc.train
sc.test = window(sc,start = 61)
sc.test
```

Wspólny wykres

```{r}
ts.plot(sc.train, sc.test, col=1:2, lty=c(1,2))
```


## Dobór modelu ARIMA

```{r}
model <- auto.arima(sc.train)
summary(model)
```

```{r}
?Arima
```


```{r}
plot(model$residuals)
```

```{r}
tsdiag(model)
```

## Tworzenie prognozy

```{r}
fc = forecast(model, h=length(sc.test))
fc
```

```{r}
summary(model)
```


```{r}
plot(fc)
lines(sc.test, col='red')
```

Zobaczmy jak by wyglądał model AR(1)

```{r}
other_model = Arima(sc.train, order = c(1,0,0))
summary(other_model)
other_fc = forecast(other_model, h = length(sc.test))
```
```{r}
plot(other_fc)
lines(sc.test, col = 'red')
```

# Sezonowość

Sezonowość jest mocno wbudowana w strukturę. Już szereg czasowy jest definiowany razem z odpowiadającym mu prawdopodobnym okresem sezonowości. Podobnie obserwujemy już po stronie modeli ARIMA

Prosto z dokumentacji modelu arima
```
Usage

arima(x, order = c(0L, 0L, 0L),
      seasonal = list(order = c(0L, 0L, 0L), period = NA),
      xreg = NULL, include.mean = TRUE,
      transform.pars = TRUE,
      fixed = NULL, init = NULL,
      method = c("CSS-ML", "ML", "CSS"), n.cond,
      SSinit = c("Gardner1980", "Rossignol2011"),
      optim.method = "BFGS",
      optim.control = list(), kappa = 1e6)
Arguments

x	
a univariate time series
order	
A specification of the non-seasonal part of the ARIMA model: the three integer components (p, d, q) are the AR order, the degree of differencing, and the MA order.
seasonal	
A specification of the seasonal part of the ARIMA model, plus the period (which defaults to frequency(x)). This should be a list with components order and period, but a specification of just a numeric vector of length 3 will be turned into a suitable list with the specification as the order.
xreg	
Optionally, a vector or matrix of external regressors, which must have the same number of rows as x.
include.mean	
Should the ARMA model include a mean/intercept term? The default is TRUE for undifferenced series, and it is ignored for ARIMA models with differencing.
transform.pars	
logical; if true, the AR parameters are transformed to ensure that they remain in the region of stationarity. Not used for method = "CSS". For method = "ML", it has been advantageous to set transform.pars = FALSE in some cases, see also fixed.
fixed	
optional numeric vector of the same length as the total number of parameters. If supplied, only NA entries in fixed will be varied. transform.pars = TRUE will be overridden (with a warning) if any AR parameters are fixed. It may be wise to set transform.pars = FALSE when fixing MA parameters, especially near non-invertibility.
init	
optional numeric vector of initial parameter values. Missing values will be filled in, by zeroes except for regression coefficients. Values already specified in fixed will be ignored.
method	
fitting method: maximum likelihood or minimize conditional sum-of-squares. The default (unless there are missing values) is to use conditional-sum-of-squares to find starting values, then maximum likelihood. Can be abbreviated.
n.cond	
only used if fitting by conditional-sum-of-squares: the number of initial observations to ignore. It will be ignored if less than the maximum lag of an AR term.
SSinit	
a string specifying the algorithm to compute the state-space initialization of the likelihood; see KalmanLike for details. Can be abbreviated.
optim.method	
The value passed as the method argument to optim.
optim.control	
List of control parameters for optim.
kappa	
the prior variance (as a multiple of the innovations variance) for the past observations in a differenced model. Do not reduce this.
```

